'''
# Design

`esy.osm.topology` is primarily designed as a library, which targets embedding
into larger workflows. The dependency set should be kept as small as possible to
avoid as much friction as possible for this embedding.

# Development

Development should advance via merge requests. New functionality should include
tests written in `doctest` and documented using `pdoc`.

To execute tests run:

```console
$ PYTHONPATH=src python -m doctest src/esy/osm/topology/*.py
```

To compute the code coverage of tests run:

```console
$ PYTHONPATH=src coverage run --source src -m doctest src/esy/osm/topology/*.py
```

To check coverage run:

```console
$ coverage report
```

To build the documentation run (note that the documentation depends on figures
generated by the doctests above):

```console
$ PYTHONPATH=src pdoc --output public esy.osm.topology
```

## Quality assurance

The code quality is assured exclusively using `doctest`. All tests are written
in docstrings. While writing doctests is a bit cumbersome, it motivates short
and concise tests which in-turn supports a modular design. As all code examples
are automatically tested, a consistent documentation is guaranteed.

Documentation figures are generated in doctests as well and should not be
committed to the repository.

An exception are figures referenced in the README. These figures should be
presented in the code forgeries project page and thus need to available in the
repository.

To avoid inconsistencies and duplication, the README page is an almost verbatim
copy of the `esy.osm.topology.__init__.__doc__` string. The `check_readme`
function will ensure that this is the case. There are caveats however: The
README file is located in another folder, so links to figures have to be
manually adjusted. `check_readme` accounts for this.
'''

import contextlib


def check_readme():
    '''
    Ensures README.md is uptodate with module documentation. Links in the
    documentation are patched to absolute paths, so that README.md is displayed
    properly on gitlab.com and pypi.org.

    >>> check_readme()

    '''
    import re, difflib, esy.osm.topology

    project_url = 'https://gitlab.com/dlr-ve/esy/esy.osm.topology/-/raw/main'
    doc_url = 'https://dlr-ve.gitlab.io/esy/esy.osm.topology'

    doc = esy.osm.topology.__doc__

    # Replace figure links.
    doc = doc.replace('../../../../doc/figure', f'{project_url}/doc/figure')

    # Replace documentation links.
    for item in set(
        m.group(0) for m in re.finditer('`esy.osm.topology.*?`', doc)
    ):
        path = item[1:-1].split('.')
        if path[-1].endswith('()'):
            # A function link.
            url = f'{doc_url}/{"/".join(path[:-1])}.html#{path[-1][:-2]}'
        else:
            # A module link.
            url = f'{doc_url}/{"/".join(path)}.html'
        doc = doc.replace(item, f'[{item}]({url})')

    readme = open('README.md').read()
    for line in difflib.unified_diff(
        doc.splitlines(keepends=True), readme.splitlines(keepends=True),
        '<docstring>', 'README.md'
    ):
        # Add a prefix character to suppress doctests <BLANKLINE> markers.
        print('|', line, end='') #pragma: nocover


@contextlib.contextmanager
def example(path, **options):
    '''
    Context for an example figure written to the file `path`.

    The figure is configurable through `options`, which are forwarded to
    `matplotlib.pyplot.subplots()`.
    '''
    import pathlib, matplotlib, matplotlib.pyplot as plt

    # Use deterministic svg hashes.
    matplotlib.rcParams['svg.hashsalt'] = '0'

    path = pathlib.Path(path)
    path.parent.mkdir(exist_ok=True, parents=True)
    fig, ax = plt.subplots(
        subplot_kw=dict(aspect=1), figsize=(8, 4), layout='tight',
        **options
    )
    yield ax
    # Strip some metadata fields to keep SVG files more reproducible.
    fig.savefig(path, metadata={'Creator': None, 'Date': None})
    plt.close(fig)
