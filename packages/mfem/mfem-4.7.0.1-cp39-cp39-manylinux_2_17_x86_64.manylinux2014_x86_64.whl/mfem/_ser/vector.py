# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _vector
else:
    import _vector

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _vector.SWIG_PyInstanceMethod_New
_swig_new_static_method = _vector.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import mfem._ser.array
import mfem._ser.mem_manager
import mfem._ser.globals

def add_vector(*args):
    r"""
    add_vector(Vector v1, Vector v2, Vector v)
    add_vector(Vector v1, double alpha, Vector v2, Vector v)
    add_vector(double const a, Vector x, Vector y, Vector z)
    add_vector(double const a, Vector x, double const b, Vector y, Vector z)
    """
    return _vector.add_vector(*args)
add_vector = _vector.add_vector

def subtract_vector(*args):
    r"""
    subtract_vector(Vector v1, Vector v2, Vector v)
    subtract_vector(double const a, Vector x, Vector y, Vector z)
    """
    return _vector.subtract_vector(*args)
subtract_vector = _vector.subtract_vector
class VectorPtrArray(object):
    r"""Proxy of C++ mfem::Array< mfem::Vector * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vector.delete_VectorPtrArray

    def GetData(self, *args):
        r"""
        GetData(VectorPtrArray self) -> Vector
        GetData(VectorPtrArray self) -> mfem::Vector *const *
        """
        return _vector.VectorPtrArray_GetData(self, *args)
    GetData = _swig_new_instance_method(_vector.VectorPtrArray_GetData)

    def GetMemory(self, *args):
        r"""
        GetMemory(VectorPtrArray self) -> mfem::Memory< mfem::Vector * >
        GetMemory(VectorPtrArray self) -> mfem::Memory< mfem::Vector * > const &
        """
        return _vector.VectorPtrArray_GetMemory(self, *args)
    GetMemory = _swig_new_instance_method(_vector.VectorPtrArray_GetMemory)

    def UseDevice(self):
        r"""UseDevice(VectorPtrArray self) -> bool"""
        return _vector.VectorPtrArray_UseDevice(self)
    UseDevice = _swig_new_instance_method(_vector.VectorPtrArray_UseDevice)

    def OwnsData(self):
        r"""OwnsData(VectorPtrArray self) -> bool"""
        return _vector.VectorPtrArray_OwnsData(self)
    OwnsData = _swig_new_instance_method(_vector.VectorPtrArray_OwnsData)

    def StealData(self, p):
        r"""StealData(VectorPtrArray self, mfem::Vector *** p)"""
        return _vector.VectorPtrArray_StealData(self, p)
    StealData = _swig_new_instance_method(_vector.VectorPtrArray_StealData)

    def LoseData(self):
        r"""LoseData(VectorPtrArray self)"""
        return _vector.VectorPtrArray_LoseData(self)
    LoseData = _swig_new_instance_method(_vector.VectorPtrArray_LoseData)

    def MakeDataOwner(self):
        r"""MakeDataOwner(VectorPtrArray self)"""
        return _vector.VectorPtrArray_MakeDataOwner(self)
    MakeDataOwner = _swig_new_instance_method(_vector.VectorPtrArray_MakeDataOwner)

    def Size(self):
        r"""Size(VectorPtrArray self) -> int"""
        return _vector.VectorPtrArray_Size(self)
    Size = _swig_new_instance_method(_vector.VectorPtrArray_Size)

    def SetSize(self, *args):
        r"""
        SetSize(VectorPtrArray self, int nsize)
        SetSize(VectorPtrArray self, int nsize, Vector initval)
        SetSize(VectorPtrArray self, int nsize, mfem::MemoryType mt)
        """
        return _vector.VectorPtrArray_SetSize(self, *args)
    SetSize = _swig_new_instance_method(_vector.VectorPtrArray_SetSize)

    def Capacity(self):
        r"""Capacity(VectorPtrArray self) -> int"""
        return _vector.VectorPtrArray_Capacity(self)
    Capacity = _swig_new_instance_method(_vector.VectorPtrArray_Capacity)

    def Reserve(self, capacity):
        r"""Reserve(VectorPtrArray self, int capacity)"""
        return _vector.VectorPtrArray_Reserve(self, capacity)
    Reserve = _swig_new_instance_method(_vector.VectorPtrArray_Reserve)

    def Append(self, *args):
        r"""
        Append(VectorPtrArray self, Vector el) -> int
        Append(VectorPtrArray self, mfem::Vector *const * els, int nels) -> int
        Append(VectorPtrArray self, VectorPtrArray els) -> int
        """

        if isinstance(args[0], list):
           return self.Append(self.__class__(args[0]))
        if isinstance(args[0], tuple):
           return self.Append(self.__class__(args[0]))


        return _vector.VectorPtrArray_Append(self, *args)


    def Prepend(self, el):
        r"""Prepend(VectorPtrArray self, Vector el) -> int"""
        return _vector.VectorPtrArray_Prepend(self, el)
    Prepend = _swig_new_instance_method(_vector.VectorPtrArray_Prepend)

    def Last(self, *args):
        r"""
        Last(VectorPtrArray self) -> Vector
        Last(VectorPtrArray self) -> Vector
        """
        return _vector.VectorPtrArray_Last(self, *args)
    Last = _swig_new_instance_method(_vector.VectorPtrArray_Last)

    def DeleteLast(self):
        r"""DeleteLast(VectorPtrArray self)"""
        return _vector.VectorPtrArray_DeleteLast(self)
    DeleteLast = _swig_new_instance_method(_vector.VectorPtrArray_DeleteLast)

    def DeleteAll(self):
        r"""DeleteAll(VectorPtrArray self)"""
        return _vector.VectorPtrArray_DeleteAll(self)
    DeleteAll = _swig_new_instance_method(_vector.VectorPtrArray_DeleteAll)

    def Copy(self, copy):
        r"""Copy(VectorPtrArray self, VectorPtrArray copy)"""
        return _vector.VectorPtrArray_Copy(self, copy)
    Copy = _swig_new_instance_method(_vector.VectorPtrArray_Copy)

    def MakeRef(self, *args):
        r"""
        MakeRef(VectorPtrArray self, mfem::Vector ** data_, int size_, bool own_data=False)
        MakeRef(VectorPtrArray self, mfem::Vector ** data_, int size, mfem::MemoryType mt, bool own_data)
        MakeRef(VectorPtrArray self, VectorPtrArray master)
        """
        return _vector.VectorPtrArray_MakeRef(self, *args)
    MakeRef = _swig_new_instance_method(_vector.VectorPtrArray_MakeRef)

    def GetSubArray(self, offset, sa_size, sa):
        r"""GetSubArray(VectorPtrArray self, int offset, int sa_size, VectorPtrArray sa)"""
        return _vector.VectorPtrArray_GetSubArray(self, offset, sa_size, sa)
    GetSubArray = _swig_new_instance_method(_vector.VectorPtrArray_GetSubArray)

    def begin(self, *args):
        r"""
        begin(VectorPtrArray self) -> Vector
        begin(VectorPtrArray self) -> mfem::Vector *const *
        """
        return _vector.VectorPtrArray_begin(self, *args)
    begin = _swig_new_instance_method(_vector.VectorPtrArray_begin)

    def end(self, *args):
        r"""
        end(VectorPtrArray self) -> Vector
        end(VectorPtrArray self) -> mfem::Vector *const *
        """
        return _vector.VectorPtrArray_end(self, *args)
    end = _swig_new_instance_method(_vector.VectorPtrArray_end)

    def MemoryUsage(self):
        r"""MemoryUsage(VectorPtrArray self) -> std::size_t"""
        return _vector.VectorPtrArray_MemoryUsage(self)
    MemoryUsage = _swig_new_instance_method(_vector.VectorPtrArray_MemoryUsage)

    def Read(self, on_dev=True):
        r"""Read(VectorPtrArray self, bool on_dev=True) -> mfem::Vector *const *"""
        return _vector.VectorPtrArray_Read(self, on_dev)
    Read = _swig_new_instance_method(_vector.VectorPtrArray_Read)

    def HostRead(self):
        r"""HostRead(VectorPtrArray self) -> mfem::Vector *const *"""
        return _vector.VectorPtrArray_HostRead(self)
    HostRead = _swig_new_instance_method(_vector.VectorPtrArray_HostRead)

    def Write(self, on_dev=True):
        r"""Write(VectorPtrArray self, bool on_dev=True) -> mfem::Vector **"""
        return _vector.VectorPtrArray_Write(self, on_dev)
    Write = _swig_new_instance_method(_vector.VectorPtrArray_Write)

    def HostWrite(self):
        r"""HostWrite(VectorPtrArray self) -> mfem::Vector **"""
        return _vector.VectorPtrArray_HostWrite(self)
    HostWrite = _swig_new_instance_method(_vector.VectorPtrArray_HostWrite)

    def ReadWrite(self, on_dev=True):
        r"""ReadWrite(VectorPtrArray self, bool on_dev=True) -> mfem::Vector **"""
        return _vector.VectorPtrArray_ReadWrite(self, on_dev)
    ReadWrite = _swig_new_instance_method(_vector.VectorPtrArray_ReadWrite)

    def HostReadWrite(self):
        r"""HostReadWrite(VectorPtrArray self) -> mfem::Vector **"""
        return _vector.VectorPtrArray_HostReadWrite(self)
    HostReadWrite = _swig_new_instance_method(_vector.VectorPtrArray_HostReadWrite)

    def __init__(self, *args):
        r"""
        __init__(VectorPtrArray self) -> VectorPtrArray
        __init__(VectorPtrArray self, mfem::MemoryType mt) -> VectorPtrArray
        __init__(VectorPtrArray self, int asize) -> VectorPtrArray
        __init__(VectorPtrArray self, int asize, mfem::MemoryType mt) -> VectorPtrArray
        __init__(VectorPtrArray self, mfem::Vector ** data_, bool own_data=False) -> VectorPtrArray
        __init__(VectorPtrArray self, VectorPtrArray src) -> VectorPtrArray
        __init__(VectorPtrArray self, VectorPtrArray src) -> VectorPtrArray
        __init__(VectorPtrArray self, void * List_or_Tuple) -> VectorPtrArray
        """
        _vector.VectorPtrArray_swiginit(self, _vector.new_VectorPtrArray(*args))

    def __setitem__(self, i, v):
        r"""__setitem__(VectorPtrArray self, int i, Vector v)"""

        i = int(i)


        return _vector.VectorPtrArray___setitem__(self, i, v)


    def Assign(self, *args):
        r"""
        Assign(VectorPtrArray self, mfem::Vector *const * arg2)
        Assign(VectorPtrArray self, Vector a)
        """
        return _vector.VectorPtrArray_Assign(self, *args)
    Assign = _swig_new_instance_method(_vector.VectorPtrArray_Assign)

    def ToList(self):
        return [self[i] for i in range(self.Size())]



    def __iter__(self):
        class iter_array:
            def __init__(self, obj):
                self.obj = obj
                self.idx = 0
                self.size = obj.Size()
            def __iter__(self):
                self.idx = 0
            def __next__(self):
                if self.idx < self.size:
                    res = self.obj[self.idx]
                    self.idx += 1
                    return res
                else:
                    raise StopIteration
        return iter_array(self)



    def __getitem__(self, param):
        r"""__getitem__(VectorPtrArray self, PyObject * param) -> PyObject *"""
        return _vector.VectorPtrArray___getitem__(self, param)
    __getitem__ = _swig_new_instance_method(_vector.VectorPtrArray___getitem__)

# Register VectorPtrArray in _vector:
_vector.VectorPtrArray_swigregister(VectorPtrArray)

def Swap(*args):
    r"""
    Swap(intArray arg1, intArray arg2)
    Swap(doubleArray arg1, doubleArray arg2)
    Swap(int8Array arg1, int8Array arg2)
    Swap(int64Array arg1, int64Array arg2)
    Swap(boolArray arg1, boolArray arg2)
    Swap(uintArray arg1, uintArray arg2)
    Swap(intArray2D arg1, intArray2D arg2)
    Swap(doubleArray2D arg1, doubleArray2D arg2)
    Swap(intArrayPtrArray arg1, intArrayPtrArray arg2)
    Swap(VectorPtrArray arg1, VectorPtrArray arg2)
    """
    return _vector.Swap(*args)
Swap = _vector.Swap


def CheckFinite(v, n):
    r"""CheckFinite(mfem::real_t const * v, int const n) -> int"""
    return _vector.CheckFinite(v, n)
CheckFinite = _vector.CheckFinite

def infinity():
    r"""infinity() -> mfem::real_t"""
    return _vector.infinity()
infinity = _vector.infinity

def rand_real():
    r"""rand_real() -> mfem::real_t"""
    return _vector.rand_real()
rand_real = _vector.rand_real
class Vector(object):
    r"""Proxy of C++ mfem::Vector class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def UseDevice(self, *args):
        r"""
        UseDevice(Vector self, bool use_dev)
        UseDevice(Vector self) -> bool
        """
        return _vector.Vector_UseDevice(self, *args)
    UseDevice = _swig_new_instance_method(_vector.Vector_UseDevice)

    def Load(self, *args):
        r"""
        Load(Vector self, std::istream ** _in, int np, int * dim)
        Load(Vector self, std::istream & _in, int Size)
        Load(Vector self, std::istream & _in)
        """
        return _vector.Vector_Load(self, *args)
    Load = _swig_new_instance_method(_vector.Vector_Load)

    def SetSize(self, *args):
        r"""
        SetSize(Vector self, int s)
        SetSize(Vector self, int s, mfem::MemoryType mt)
        SetSize(Vector self, int s, Vector v)
        """
        return _vector.Vector_SetSize(self, *args)
    SetSize = _swig_new_instance_method(_vector.Vector_SetSize)

    def SetData(self, d):
        r"""SetData(Vector self, mfem::real_t * d)"""
        return _vector.Vector_SetData(self, d)
    SetData = _swig_new_instance_method(_vector.Vector_SetData)

    def SetDataAndSize(self, d, s):
        r"""SetDataAndSize(Vector self, mfem::real_t * d, int s)"""
        return _vector.Vector_SetDataAndSize(self, d, s)
    SetDataAndSize = _swig_new_instance_method(_vector.Vector_SetDataAndSize)

    def NewDataAndSize(self, d, s):
        r"""NewDataAndSize(Vector self, mfem::real_t * d, int s)"""
        return _vector.Vector_NewDataAndSize(self, d, s)
    NewDataAndSize = _swig_new_instance_method(_vector.Vector_NewDataAndSize)

    def NewMemoryAndSize(self, mem, s, own_mem):
        r"""NewMemoryAndSize(Vector self, mfem::Memory< mfem::real_t > const & mem, int s, bool own_mem)"""
        return _vector.Vector_NewMemoryAndSize(self, mem, s, own_mem)
    NewMemoryAndSize = _swig_new_instance_method(_vector.Vector_NewMemoryAndSize)

    def MakeRef(self, *args):
        r"""
        MakeRef(Vector self, Vector base, int offset, int size)
        MakeRef(Vector self, Vector base, int offset)
        """
        return _vector.Vector_MakeRef(self, *args)
    MakeRef = _swig_new_instance_method(_vector.Vector_MakeRef)

    def MakeDataOwner(self):
        r"""MakeDataOwner(Vector self)"""
        return _vector.Vector_MakeDataOwner(self)
    MakeDataOwner = _swig_new_instance_method(_vector.Vector_MakeDataOwner)

    def Destroy(self):
        r"""Destroy(Vector self)"""
        return _vector.Vector_Destroy(self)
    Destroy = _swig_new_instance_method(_vector.Vector_Destroy)

    def DeleteDevice(self, copy_to_host=True):
        r"""DeleteDevice(Vector self, bool copy_to_host=True)"""
        return _vector.Vector_DeleteDevice(self, copy_to_host)
    DeleteDevice = _swig_new_instance_method(_vector.Vector_DeleteDevice)

    def Size(self):
        r"""Size(Vector self) -> int"""
        return _vector.Vector_Size(self)
    Size = _swig_new_instance_method(_vector.Vector_Size)

    def Capacity(self):
        r"""Capacity(Vector self) -> int"""
        return _vector.Vector_Capacity(self)
    Capacity = _swig_new_instance_method(_vector.Vector_Capacity)

    def GetData(self):
        r"""GetData(Vector self) -> mfem::real_t *"""
        return _vector.Vector_GetData(self)
    GetData = _swig_new_instance_method(_vector.Vector_GetData)

    def begin(self, *args):
        r"""
        begin(Vector self) -> mfem::real_t
        begin(Vector self) -> mfem::real_t const *
        """
        return _vector.Vector_begin(self, *args)
    begin = _swig_new_instance_method(_vector.Vector_begin)

    def end(self, *args):
        r"""
        end(Vector self) -> mfem::real_t
        end(Vector self) -> mfem::real_t const *
        """
        return _vector.Vector_end(self, *args)
    end = _swig_new_instance_method(_vector.Vector_end)

    def GetMemory(self, *args):
        r"""
        GetMemory(Vector self) -> mfem::Memory< mfem::real_t >
        GetMemory(Vector self) -> mfem::Memory< mfem::real_t > const &
        """
        return _vector.Vector_GetMemory(self, *args)
    GetMemory = _swig_new_instance_method(_vector.Vector_GetMemory)

    def SyncMemory(self, v):
        r"""SyncMemory(Vector self, Vector v)"""
        return _vector.Vector_SyncMemory(self, v)
    SyncMemory = _swig_new_instance_method(_vector.Vector_SyncMemory)

    def SyncAliasMemory(self, v):
        r"""SyncAliasMemory(Vector self, Vector v)"""
        return _vector.Vector_SyncAliasMemory(self, v)
    SyncAliasMemory = _swig_new_instance_method(_vector.Vector_SyncAliasMemory)

    def OwnsData(self):
        r"""OwnsData(Vector self) -> bool"""
        return _vector.Vector_OwnsData(self)
    OwnsData = _swig_new_instance_method(_vector.Vector_OwnsData)

    def StealData(self, *args):
        r"""
        StealData(Vector self, mfem::real_t ** p)
        StealData(Vector self) -> mfem::real_t *
        """
        return _vector.Vector_StealData(self, *args)
    StealData = _swig_new_instance_method(_vector.Vector_StealData)

    def Elem(self, *args):
        r"""
        Elem(Vector self, int i) -> mfem::real_t
        Elem(Vector self, int i) -> mfem::real_t const &
        """
        return _vector.Vector_Elem(self, *args)
    Elem = _swig_new_instance_method(_vector.Vector_Elem)

    def __call__(self, *args):
        r"""
        __call__(Vector self, int i) -> mfem::real_t
        __call__(Vector self, int i) -> mfem::real_t const &
        """
        return _vector.Vector___call__(self, *args)
    __call__ = _swig_new_instance_method(_vector.Vector___call__)

    def __mul__(self, *args):
        r"""
        __mul__(Vector self, mfem::real_t const * arg2) -> mfem::real_t
        __mul__(Vector self, Vector v) -> mfem::real_t
        """
        return _vector.Vector___mul__(self, *args)
    __mul__ = _swig_new_instance_method(_vector.Vector___mul__)

    def __imul__(self, v):
        ret = _vector.Vector___imul__(self, v)
    #ret.thisown = self.thisown
        ret.thisown = 0
        return self



    def __itruediv__(self, v):
        ret = _vector.Vector___itruediv__(self, v)
    #ret.thisown = self.thisown
        ret.thisown = 0
        return self



    def __isub__(self, v):
        ret = _vector.Vector___isub__(self, v)
    #ret.thisown = self.thisown
        ret.thisown = 0
        return self



    def __iadd__(self, v):
        ret = _vector.Vector___iadd__(self, v)
    #ret.thisown = self.thisown
        ret.thisown = 0
        return self



    def Add(self, a, Va):
        r"""Add(Vector self, mfem::real_t const a, Vector Va) -> Vector"""
        return _vector.Vector_Add(self, a, Va)
    Add = _swig_new_instance_method(_vector.Vector_Add)

    def Set(self, a, x):
        r"""Set(Vector self, mfem::real_t const a, Vector x) -> Vector"""
        return _vector.Vector_Set(self, a, x)
    Set = _swig_new_instance_method(_vector.Vector_Set)

    def SetVector(self, v, offset):
        r"""SetVector(Vector self, Vector v, int offset)"""
        return _vector.Vector_SetVector(self, v, offset)
    SetVector = _swig_new_instance_method(_vector.Vector_SetVector)

    def AddSubVector(self, v, offset):
        r"""AddSubVector(Vector self, Vector v, int offset)"""
        return _vector.Vector_AddSubVector(self, v, offset)
    AddSubVector = _swig_new_instance_method(_vector.Vector_AddSubVector)

    def Neg(self):
        r"""Neg(Vector self)"""
        return _vector.Vector_Neg(self)
    Neg = _swig_new_instance_method(_vector.Vector_Neg)

    def Reciprocal(self):
        r"""Reciprocal(Vector self)"""
        return _vector.Vector_Reciprocal(self)
    Reciprocal = _swig_new_instance_method(_vector.Vector_Reciprocal)

    def Swap(self, other):
        r"""Swap(Vector self, Vector other)"""
        return _vector.Vector_Swap(self, other)
    Swap = _swig_new_instance_method(_vector.Vector_Swap)

    def cross3D(self, vin, vout):
        r"""cross3D(Vector self, Vector vin, Vector vout)"""
        return _vector.Vector_cross3D(self, vin, vout)
    cross3D = _swig_new_instance_method(_vector.Vector_cross3D)

    def median(self, lo, hi):
        r"""median(Vector self, Vector lo, Vector hi)"""
        return _vector.Vector_median(self, lo, hi)
    median = _swig_new_instance_method(_vector.Vector_median)

    def GetSubVector(self, *args):
        r"""
        GetSubVector(Vector self, intArray dofs, Vector elemvect)
        GetSubVector(Vector self, intArray dofs, mfem::real_t * elem_data)
        """
        return _vector.Vector_GetSubVector(self, *args)
    GetSubVector = _swig_new_instance_method(_vector.Vector_GetSubVector)

    def SetSubVector(self, *args):
        r"""
        SetSubVector(Vector self, intArray dofs, mfem::real_t const value)
        SetSubVector(Vector self, intArray dofs, Vector elemvect)
        SetSubVector(Vector self, intArray dofs, mfem::real_t * elem_data)
        """
        return _vector.Vector_SetSubVector(self, *args)
    SetSubVector = _swig_new_instance_method(_vector.Vector_SetSubVector)

    def AddElementVector(self, *args):
        r"""
        AddElementVector(Vector self, intArray dofs, Vector elemvect)
        AddElementVector(Vector self, intArray dofs, mfem::real_t * elem_data)
        AddElementVector(Vector self, intArray dofs, mfem::real_t const a, Vector elemvect)
        """
        return _vector.Vector_AddElementVector(self, *args)
    AddElementVector = _swig_new_instance_method(_vector.Vector_AddElementVector)

    def SetSubVectorComplement(self, dofs, val):
        r"""SetSubVectorComplement(Vector self, intArray dofs, mfem::real_t const val)"""
        return _vector.Vector_SetSubVectorComplement(self, dofs, val)
    SetSubVectorComplement = _swig_new_instance_method(_vector.Vector_SetSubVectorComplement)

    def PrintHash(self, out):
        r"""PrintHash(Vector self, std::ostream & out)"""
        return _vector.Vector_PrintHash(self, out)
    PrintHash = _swig_new_instance_method(_vector.Vector_PrintHash)

    def Randomize(self, seed=0):
        r"""Randomize(Vector self, int seed=0)"""
        return _vector.Vector_Randomize(self, seed)
    Randomize = _swig_new_instance_method(_vector.Vector_Randomize)

    def Norml2(self):
        r"""Norml2(Vector self) -> mfem::real_t"""
        return _vector.Vector_Norml2(self)
    Norml2 = _swig_new_instance_method(_vector.Vector_Norml2)

    def Normlinf(self):
        r"""Normlinf(Vector self) -> mfem::real_t"""
        return _vector.Vector_Normlinf(self)
    Normlinf = _swig_new_instance_method(_vector.Vector_Normlinf)

    def Norml1(self):
        r"""Norml1(Vector self) -> mfem::real_t"""
        return _vector.Vector_Norml1(self)
    Norml1 = _swig_new_instance_method(_vector.Vector_Norml1)

    def Normlp(self, p):
        r"""Normlp(Vector self, mfem::real_t p) -> mfem::real_t"""
        return _vector.Vector_Normlp(self, p)
    Normlp = _swig_new_instance_method(_vector.Vector_Normlp)

    def Max(self):
        r"""Max(Vector self) -> mfem::real_t"""
        return _vector.Vector_Max(self)
    Max = _swig_new_instance_method(_vector.Vector_Max)

    def Min(self):
        r"""Min(Vector self) -> mfem::real_t"""
        return _vector.Vector_Min(self)
    Min = _swig_new_instance_method(_vector.Vector_Min)

    def Sum(self):
        r"""Sum(Vector self) -> mfem::real_t"""
        return _vector.Vector_Sum(self)
    Sum = _swig_new_instance_method(_vector.Vector_Sum)

    def DistanceSquaredTo(self, *args):
        r"""
        DistanceSquaredTo(Vector self, mfem::real_t const * p) -> mfem::real_t
        DistanceSquaredTo(Vector self, Vector p) -> mfem::real_t
        """
        return _vector.Vector_DistanceSquaredTo(self, *args)
    DistanceSquaredTo = _swig_new_instance_method(_vector.Vector_DistanceSquaredTo)

    def DistanceTo(self, *args):
        r"""
        DistanceTo(Vector self, mfem::real_t const * p) -> mfem::real_t
        DistanceTo(Vector self, Vector p) -> mfem::real_t
        """
        return _vector.Vector_DistanceTo(self, *args)
    DistanceTo = _swig_new_instance_method(_vector.Vector_DistanceTo)

    def CheckFinite(self):
        r"""CheckFinite(Vector self) -> int"""
        return _vector.Vector_CheckFinite(self)
    CheckFinite = _swig_new_instance_method(_vector.Vector_CheckFinite)
    __swig_destroy__ = _vector.delete_Vector

    def Read(self, on_dev=True):
        r"""Read(Vector self, bool on_dev=True) -> mfem::real_t const *"""
        return _vector.Vector_Read(self, on_dev)
    Read = _swig_new_instance_method(_vector.Vector_Read)

    def HostRead(self):
        r"""HostRead(Vector self) -> mfem::real_t const *"""
        return _vector.Vector_HostRead(self)
    HostRead = _swig_new_instance_method(_vector.Vector_HostRead)

    def Write(self, on_dev=True):
        r"""Write(Vector self, bool on_dev=True) -> mfem::real_t *"""
        return _vector.Vector_Write(self, on_dev)
    Write = _swig_new_instance_method(_vector.Vector_Write)

    def HostWrite(self):
        r"""HostWrite(Vector self) -> mfem::real_t *"""
        return _vector.Vector_HostWrite(self)
    HostWrite = _swig_new_instance_method(_vector.Vector_HostWrite)

    def ReadWrite(self, on_dev=True):
        r"""ReadWrite(Vector self, bool on_dev=True) -> mfem::real_t *"""
        return _vector.Vector_ReadWrite(self, on_dev)
    ReadWrite = _swig_new_instance_method(_vector.Vector_ReadWrite)

    def HostReadWrite(self):
        r"""HostReadWrite(Vector self) -> mfem::real_t *"""
        return _vector.Vector_HostReadWrite(self)
    HostReadWrite = _swig_new_instance_method(_vector.Vector_HostReadWrite)

    def __init__(self, *args):
        r"""
        __init__(Vector self) -> Vector
        __init__(Vector self, Vector arg2) -> Vector
        __init__(Vector self, Vector v) -> Vector
        __init__(Vector self, int s) -> Vector
        __init__(Vector self, mfem::real_t * data_, int size_) -> Vector
        __init__(Vector self, Vector base, int base_offset, int size_) -> Vector
        __init__(Vector self, int size_, mfem::MemoryType mt) -> Vector
        __init__(Vector self, int size_, mfem::MemoryType h_mt, mfem::MemoryType d_mt) -> Vector
        __init__(Vector self, Vector v, int offset, int size) -> Vector
        """

        from numpy import ndarray, ascontiguousarray
        keep_link = False
        own_data = False
        if len(args) == 1:
            if isinstance(args[0], list):
                args = (args[0], len(args[0]))
                own_data = True
            elif isinstance(args[0], ndarray):
                if args[0].dtype != 'float64':
                    raise ValueError('Must be float64 array ' + str(args[0].dtype) +
        			     ' is given')
                else:
                    args = (ascontiguousarray(args[0]), args[0].shape[0])
        # in this case, args[0] need to be maintained
        # in this object.
                    keep_link = True


        _vector.Vector_swiginit(self, _vector.new_Vector(*args))

        if keep_link:
           self._link_to_data = args[0]
        if own_data:
           self.MakeDataOwner()




    def Assign(self, *args):
        r"""
        Assign(Vector self, double const v)
        Assign(Vector self, Vector v)
        Assign(Vector self, PyObject * param)
        """

        from numpy import ndarray, ascontiguousarray, array
        keep_link = False
        if len(args) == 1:
            if isinstance(args[0], ndarray):
                if args[0].dtype != 'float64':
                    raise ValueError('Must be float64 array ' + str(args[0].dtype) +
        		   ' is given')
                elif args[0].ndim != 1:
                    raise ValueError('Ndim must be one')
                elif args[0].shape[0] != self.Size():
                    raise ValueError('Length does not match')
                else:
                    args = (ascontiguousarray(args[0]),)
            elif isinstance(args[0], tuple):
                args = (array(args[0], dtype = float),)
            elif isinstance(args[0], list):
                args = (array(args[0], dtype = float),)
            else:
                pass


        val = _vector.Vector_Assign(self, *args)

        return self


        return val


    def __setitem__(self, i, v):
        r"""__setitem__(Vector self, int i, double const v)"""
        return _vector.Vector___setitem__(self, i, v)
    __setitem__ = _swig_new_instance_method(_vector.Vector___setitem__)

    def __getitem__(self, param):
        r"""__getitem__(Vector self, PyObject * param) -> PyObject *"""
        return _vector.Vector___getitem__(self, param)
    __getitem__ = _swig_new_instance_method(_vector.Vector___getitem__)

    def GetDataArray(self):
        r"""GetDataArray(Vector self) -> PyObject *"""
        return _vector.Vector_GetDataArray(self)
    GetDataArray = _swig_new_instance_method(_vector.Vector_GetDataArray)

    def WriteToStream(self, StringIO, width=8):
        r"""WriteToStream(Vector self, PyObject * StringIO, int width=8) -> PyObject *"""
        return _vector.Vector_WriteToStream(self, StringIO, width)
    WriteToStream = _swig_new_instance_method(_vector.Vector_WriteToStream)

    def Print(self, *args):
        r"""
        Print(Vector self, std::ostream & out=out, int width=8)
        Print(Vector self, char const * file, int precision=16)
        """
        return _vector.Vector_Print(self, *args)
    Print = _swig_new_instance_method(_vector.Vector_Print)

    def PrintGZ(self, file, precision=16):
        r"""PrintGZ(Vector self, char const * file, int precision=16)"""
        return _vector.Vector_PrintGZ(self, file, precision)
    PrintGZ = _swig_new_instance_method(_vector.Vector_PrintGZ)

    def Print_HYPREGZ(self, file, precision=16):
        r"""Print_HYPREGZ(Vector self, char const * file, int precision=16)"""
        return _vector.Vector_Print_HYPREGZ(self, file, precision)
    Print_HYPREGZ = _swig_new_instance_method(_vector.Vector_Print_HYPREGZ)

    def Print_HYPRE(self, *args):
        r"""
        Print_HYPRE(Vector self, std::ostream & out)
        Print_HYPRE(Vector self, char const * file, int precision=16)
        Print_HYPRE(Vector self)
        """
        return _vector.Vector_Print_HYPRE(self, *args)
    Print_HYPRE = _swig_new_instance_method(_vector.Vector_Print_HYPRE)

# Register Vector in _vector:
_vector.Vector_swigregister(Vector)

def IsFinite(val):
    r"""IsFinite(mfem::real_t const & val) -> bool"""
    return _vector.IsFinite(val)
IsFinite = _vector.IsFinite

def DistanceSquared(x, y, n):
    r"""DistanceSquared(mfem::real_t const * x, mfem::real_t const * y, int const n) -> mfem::real_t"""
    return _vector.DistanceSquared(x, y, n)
DistanceSquared = _vector.DistanceSquared

def Distance(*args):
    r"""
    Distance(mfem::real_t const * x, mfem::real_t const * y, int const n) -> mfem::real_t
    Distance(Vector x, Vector y) -> mfem::real_t
    """
    return _vector.Distance(*args)
Distance = _vector.Distance

Vector.__idiv__ = Vector.__itruediv__


