# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _hyperbolic
else:
    import _hyperbolic

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _hyperbolic.SWIG_PyInstanceMethod_New
_swig_new_static_method = _hyperbolic.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

import mfem._ser.array
import mfem._ser.mem_manager
import mfem._ser.globals
import mfem._ser.vector
import mfem._ser.densemat
import mfem._ser.operators
import mfem._ser.matrix
import mfem._ser.eltrans
import mfem._ser.fe
import mfem._ser.geom
import mfem._ser.intrules
import mfem._ser.sparsemat
import mfem._ser.fe_base
import mfem._ser.doftrans
import mfem._ser.fe_fixed_order
import mfem._ser.element
import mfem._ser.table
import mfem._ser.hash
import mfem._ser.fe_h1
import mfem._ser.fe_nd
import mfem._ser.fe_rt
import mfem._ser.fe_l2
import mfem._ser.fe_nurbs
import mfem._ser.fe_pos
import mfem._ser.fe_ser
import mfem._ser.nonlininteg
import mfem._ser.fespace
import mfem._ser.coefficient
import mfem._ser.symmat
import mfem._ser.mesh
import mfem._ser.attribute_sets
import mfem._ser.arrays_by_name
import mfem._ser.sort_pairs
import mfem._ser.ncmesh
import mfem._ser.gridfunc
import mfem._ser.bilininteg
import mfem._ser.fe_coll
import mfem._ser.lininteg
import mfem._ser.linearform
import mfem._ser.vertex
import mfem._ser.vtk
import mfem._ser.std_vectors
import mfem._ser.handle
import mfem._ser.restriction
class FluxFunction(object):
    r"""Proxy of C++ mfem::FluxFunction class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    num_equations = property(_hyperbolic.FluxFunction_num_equations_get, doc=r"""num_equations : q(const).int""")
    dim = property(_hyperbolic.FluxFunction_dim_get, doc=r"""dim : q(const).int""")

    def ComputeFlux(self, state, Tr, flux):
        r"""ComputeFlux(FluxFunction self, Vector state, ElementTransformation Tr, DenseMatrix flux) -> mfem::real_t"""
        return _hyperbolic.FluxFunction_ComputeFlux(self, state, Tr, flux)
    ComputeFlux = _swig_new_instance_method(_hyperbolic.FluxFunction_ComputeFlux)

    def ComputeFluxDotN(self, state, normal, Tr, fluxDotN):
        r"""ComputeFluxDotN(FluxFunction self, Vector state, Vector normal, FaceElementTransformations Tr, Vector fluxDotN) -> mfem::real_t"""
        return _hyperbolic.FluxFunction_ComputeFluxDotN(self, state, normal, Tr, fluxDotN)
    ComputeFluxDotN = _swig_new_instance_method(_hyperbolic.FluxFunction_ComputeFluxDotN)

    def ComputeFluxJacobian(self, state, Tr, J):
        r"""ComputeFluxJacobian(FluxFunction self, Vector state, ElementTransformation Tr, DenseTensor J)"""
        return _hyperbolic.FluxFunction_ComputeFluxJacobian(self, state, Tr, J)
    ComputeFluxJacobian = _swig_new_instance_method(_hyperbolic.FluxFunction_ComputeFluxJacobian)
    __swig_destroy__ = _hyperbolic.delete_FluxFunction

# Register FluxFunction in _hyperbolic:
_hyperbolic.FluxFunction_swigregister(FluxFunction)
class RiemannSolver(object):
    r"""Proxy of C++ mfem::RiemannSolver class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Eval(self, state1, state2, nor, Tr, flux):
        r"""Eval(RiemannSolver self, Vector state1, Vector state2, Vector nor, FaceElementTransformations Tr, Vector flux) -> mfem::real_t"""
        return _hyperbolic.RiemannSolver_Eval(self, state1, state2, nor, Tr, flux)
    Eval = _swig_new_instance_method(_hyperbolic.RiemannSolver_Eval)
    __swig_destroy__ = _hyperbolic.delete_RiemannSolver

    def GetFluxFunction(self):
        r"""GetFluxFunction(RiemannSolver self) -> FluxFunction"""
        return _hyperbolic.RiemannSolver_GetFluxFunction(self)
    GetFluxFunction = _swig_new_instance_method(_hyperbolic.RiemannSolver_GetFluxFunction)

# Register RiemannSolver in _hyperbolic:
_hyperbolic.RiemannSolver_swigregister(RiemannSolver)
class HyperbolicFormIntegrator(mfem._ser.nonlininteg.NonlinearFormIntegrator):
    r"""Proxy of C++ mfem::HyperbolicFormIntegrator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_equations = property(_hyperbolic.HyperbolicFormIntegrator_num_equations_get, doc=r"""num_equations : q(const).int""")

    def __init__(self, rsolver, IntOrderOffset=0):
        r"""__init__(HyperbolicFormIntegrator self, RiemannSolver rsolver, int const IntOrderOffset=0) -> HyperbolicFormIntegrator"""
        _hyperbolic.HyperbolicFormIntegrator_swiginit(self, _hyperbolic.new_HyperbolicFormIntegrator(rsolver, IntOrderOffset))

    def ResetMaxCharSpeed(self):
        r"""ResetMaxCharSpeed(HyperbolicFormIntegrator self)"""
        return _hyperbolic.HyperbolicFormIntegrator_ResetMaxCharSpeed(self)
    ResetMaxCharSpeed = _swig_new_instance_method(_hyperbolic.HyperbolicFormIntegrator_ResetMaxCharSpeed)

    def GetMaxCharSpeed(self):
        r"""GetMaxCharSpeed(HyperbolicFormIntegrator self) -> mfem::real_t"""
        return _hyperbolic.HyperbolicFormIntegrator_GetMaxCharSpeed(self)
    GetMaxCharSpeed = _swig_new_instance_method(_hyperbolic.HyperbolicFormIntegrator_GetMaxCharSpeed)

    def GetFluxFunction(self):
        r"""GetFluxFunction(HyperbolicFormIntegrator self) -> FluxFunction"""
        return _hyperbolic.HyperbolicFormIntegrator_GetFluxFunction(self)
    GetFluxFunction = _swig_new_instance_method(_hyperbolic.HyperbolicFormIntegrator_GetFluxFunction)

    def AssembleElementVector(self, el, Tr, elfun, elvect):
        r"""AssembleElementVector(HyperbolicFormIntegrator self, FiniteElement el, ElementTransformation Tr, Vector elfun, Vector elvect)"""
        return _hyperbolic.HyperbolicFormIntegrator_AssembleElementVector(self, el, Tr, elfun, elvect)
    AssembleElementVector = _swig_new_instance_method(_hyperbolic.HyperbolicFormIntegrator_AssembleElementVector)

    def AssembleFaceVector(self, el1, el2, Tr, elfun, elvect):
        r"""AssembleFaceVector(HyperbolicFormIntegrator self, FiniteElement el1, FiniteElement el2, FaceElementTransformations Tr, Vector elfun, Vector elvect)"""
        return _hyperbolic.HyperbolicFormIntegrator_AssembleFaceVector(self, el1, el2, Tr, elfun, elvect)
    AssembleFaceVector = _swig_new_instance_method(_hyperbolic.HyperbolicFormIntegrator_AssembleFaceVector)
    __swig_destroy__ = _hyperbolic.delete_HyperbolicFormIntegrator

# Register HyperbolicFormIntegrator in _hyperbolic:
_hyperbolic.HyperbolicFormIntegrator_swigregister(HyperbolicFormIntegrator)
class RusanovFlux(RiemannSolver):
    r"""Proxy of C++ mfem::RusanovFlux class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fluxFunction):
        r"""__init__(RusanovFlux self, FluxFunction fluxFunction) -> RusanovFlux"""
        _hyperbolic.RusanovFlux_swiginit(self, _hyperbolic.new_RusanovFlux(fluxFunction))

    def Eval(self, state1, state2, nor, Tr, flux):
        r"""Eval(RusanovFlux self, Vector state1, Vector state2, Vector nor, FaceElementTransformations Tr, Vector flux) -> mfem::real_t"""
        return _hyperbolic.RusanovFlux_Eval(self, state1, state2, nor, Tr, flux)
    Eval = _swig_new_instance_method(_hyperbolic.RusanovFlux_Eval)
    __swig_destroy__ = _hyperbolic.delete_RusanovFlux

# Register RusanovFlux in _hyperbolic:
_hyperbolic.RusanovFlux_swigregister(RusanovFlux)
class AdvectionFlux(FluxFunction):
    r"""Proxy of C++ mfem::AdvectionFlux class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, b):
        r"""__init__(AdvectionFlux self, VectorCoefficient b) -> AdvectionFlux"""
        _hyperbolic.AdvectionFlux_swiginit(self, _hyperbolic.new_AdvectionFlux(b))

    def ComputeFlux(self, state, Tr, flux):
        r"""ComputeFlux(AdvectionFlux self, Vector state, ElementTransformation Tr, DenseMatrix flux) -> mfem::real_t"""
        return _hyperbolic.AdvectionFlux_ComputeFlux(self, state, Tr, flux)
    ComputeFlux = _swig_new_instance_method(_hyperbolic.AdvectionFlux_ComputeFlux)
    __swig_destroy__ = _hyperbolic.delete_AdvectionFlux

# Register AdvectionFlux in _hyperbolic:
_hyperbolic.AdvectionFlux_swigregister(AdvectionFlux)
class BurgersFlux(FluxFunction):
    r"""Proxy of C++ mfem::BurgersFlux class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dim):
        r"""__init__(BurgersFlux self, int const dim) -> BurgersFlux"""
        _hyperbolic.BurgersFlux_swiginit(self, _hyperbolic.new_BurgersFlux(dim))

    def ComputeFlux(self, state, Tr, flux):
        r"""ComputeFlux(BurgersFlux self, Vector state, ElementTransformation Tr, DenseMatrix flux) -> mfem::real_t"""
        return _hyperbolic.BurgersFlux_ComputeFlux(self, state, Tr, flux)
    ComputeFlux = _swig_new_instance_method(_hyperbolic.BurgersFlux_ComputeFlux)
    __swig_destroy__ = _hyperbolic.delete_BurgersFlux

# Register BurgersFlux in _hyperbolic:
_hyperbolic.BurgersFlux_swigregister(BurgersFlux)
class ShallowWaterFlux(FluxFunction):
    r"""Proxy of C++ mfem::ShallowWaterFlux class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dim, g=9.8):
        r"""__init__(ShallowWaterFlux self, int const dim, mfem::real_t const g=9.8) -> ShallowWaterFlux"""
        _hyperbolic.ShallowWaterFlux_swiginit(self, _hyperbolic.new_ShallowWaterFlux(dim, g))

    def ComputeFlux(self, state, Tr, flux):
        r"""ComputeFlux(ShallowWaterFlux self, Vector state, ElementTransformation Tr, DenseMatrix flux) -> mfem::real_t"""
        return _hyperbolic.ShallowWaterFlux_ComputeFlux(self, state, Tr, flux)
    ComputeFlux = _swig_new_instance_method(_hyperbolic.ShallowWaterFlux_ComputeFlux)

    def ComputeFluxDotN(self, state, normal, Tr, fluxN):
        r"""ComputeFluxDotN(ShallowWaterFlux self, Vector state, Vector normal, FaceElementTransformations Tr, Vector fluxN) -> mfem::real_t"""
        return _hyperbolic.ShallowWaterFlux_ComputeFluxDotN(self, state, normal, Tr, fluxN)
    ComputeFluxDotN = _swig_new_instance_method(_hyperbolic.ShallowWaterFlux_ComputeFluxDotN)
    __swig_destroy__ = _hyperbolic.delete_ShallowWaterFlux

# Register ShallowWaterFlux in _hyperbolic:
_hyperbolic.ShallowWaterFlux_swigregister(ShallowWaterFlux)
class EulerFlux(FluxFunction):
    r"""Proxy of C++ mfem::EulerFlux class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dim, specific_heat_ratio):
        r"""__init__(EulerFlux self, int const dim, mfem::real_t const specific_heat_ratio) -> EulerFlux"""
        _hyperbolic.EulerFlux_swiginit(self, _hyperbolic.new_EulerFlux(dim, specific_heat_ratio))

    def ComputeFlux(self, state, Tr, flux):
        r"""ComputeFlux(EulerFlux self, Vector state, ElementTransformation Tr, DenseMatrix flux) -> mfem::real_t"""
        return _hyperbolic.EulerFlux_ComputeFlux(self, state, Tr, flux)
    ComputeFlux = _swig_new_instance_method(_hyperbolic.EulerFlux_ComputeFlux)

    def ComputeFluxDotN(self, x, normal, Tr, fluxN):
        r"""ComputeFluxDotN(EulerFlux self, Vector x, Vector normal, FaceElementTransformations Tr, Vector fluxN) -> mfem::real_t"""
        return _hyperbolic.EulerFlux_ComputeFluxDotN(self, x, normal, Tr, fluxN)
    ComputeFluxDotN = _swig_new_instance_method(_hyperbolic.EulerFlux_ComputeFluxDotN)
    __swig_destroy__ = _hyperbolic.delete_EulerFlux

# Register EulerFlux in _hyperbolic:
_hyperbolic.EulerFlux_swigregister(EulerFlux)

