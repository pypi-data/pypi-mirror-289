"""Ant Colony Optimization (ACO) Algorithm.

This module implements the Ant Colony Optimization (ACO) algorithm. ACO is a
population-based metaheuristic that can be used to find approximate solutions to
difficult optimization problems.

In ACO, a set of software agents called artificial ants search for good solutions to a
given optimization problem. To apply ACO, the optimization problem is transformed into
the problem of finding the best path on a weighted graph. The artificial ants
incrementally build solutions by moving on the graph. The solution construction process
 is stochastic and is biased by a pheromone model, that is, a set of parameters
associated with graph components (either nodes or edges) whose values are modified
at runtime by the ants.

ACO is particularly useful for problems that can be reduced to finding paths on
weighted graphs, like the traveling salesman problem, the vehicle routing problem, and
the quadratic assignment problem.

Example:
    optimizer = AntColony(func=objective_function, lower_bound=-10, upper_bound=10,
    dim=2, n_ants=50, max_iter=1000)
    best_solution, best_fitness = optimizer.search()

Attributes:
    func (Callable): The objective function to optimize.
    lower_bound (float): The lower bound of the search space.
    upper_bound (float): The upper bound of the search space.
    dim (int): The dimension of the search space.
    n_ants (int): The number of ants (candidate solutions).
    max_iter (int): The maximum number of iterations.

Methods:
    search(): Perform the ACO optimization.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np

from opt.abstract_optimizer import AbstractOptimizer
from opt.benchmark.functions import shifted_ackley


if TYPE_CHECKING:
    from collections.abc import Callable

    from numpy import ndarray


class AntColony(AbstractOptimizer):
    """Ant Colony Optimization algorithm for optimization problems.

    Args:
        func (Callable[[ndarray], float]): The objective function to be minimized.
        lower_bound (float): The lower bound of the search space.
        upper_bound (float): The upper bound of the search space.
        dim (int): The dimensionality of the search space.
        max_iter (int, optional): The maximum number of iterations. Defaults to 1000.
        population_size (int, optional): The number of ants in the colony. Defaults to 100.
        seed (Optional[int], optional): The seed value for random number generation. Defaults to None.
        alpha (float, optional): The importance of pheromone in the solution construction. Defaults to 1.
        beta (float, optional): The importance of heuristic information in the solution construction. Defaults to 1.
        rho (float, optional): The pheromone evaporation rate. Defaults to 0.5.
        q (float, optional): The pheromone deposit factor. Defaults to 1.

    Attributes:
        alpha (float): The importance of pheromone in the solution construction.
        beta (float): The importance of heuristic information in the solution construction.
        rho (float): The pheromone evaporation rate.
        q (float): The pheromone deposit factor.
        ants (np.ndarray): The current solutions generated by the ants.
        pheromone (np.ndarray): The pheromone matrix.

    """

    def __init__(
        self,
        func: Callable[[ndarray], float],
        lower_bound: float,
        upper_bound: float,
        dim: int,
        max_iter: int = 1000,
        population_size: int = 100,
        seed: int | None = None,
        alpha: float = 1,
        beta: float = 1,
        rho: float = 0.5,
        q: float = 1,
    ) -> None:
        """Initialize the Ant Colony Optimization algorithm."""
        super().__init__(
            func=func,
            lower_bound=lower_bound,
            upper_bound=upper_bound,
            dim=dim,
            max_iter=max_iter,
            seed=seed,
            population_size=population_size,
        )

        self.alpha = alpha
        self.beta = beta
        self.rho = rho
        self.q = q
        self.ants = np.random.default_rng(self.seed).uniform(
            self.lower_bound, self.upper_bound, (self.population_size, self.dim)
        )
        self.pheromone = np.ones((self.population_size, self.dim))

    def search(self) -> tuple[np.ndarray, float]:
        """Run the Ant Colony Optimization algorithm.

        Returns:
            Tuple[np.ndarray, float]: The best solution found and its corresponding fitness value.

        """
        best_fitness = np.inf
        best_solution = None

        for _ in range(self.max_iter):
            for i in range(self.population_size):
                solution = self.ants[i]
                fitness = self.func(solution)

                if fitness < best_fitness:
                    best_fitness = fitness
                    best_solution = solution

                self.update_pheromone(i, fitness)
                self.ants[i] = self.generate_new_solution(i)

            # Local search
            for i in range(self.population_size):
                local_best = self.local_search(self.ants[i])
                local_fitness = self.func(local_best)

                if local_fitness < best_fitness:
                    best_fitness = local_fitness
                    best_solution = local_best

        return best_solution, best_fitness

    def update_pheromone(self, i: int, fitness: float) -> None:
        """Update the pheromone matrix based on the fitness of the ant's solution.

        Args:
            i (int): The index of the ant.
            fitness (float): The fitness value of the ant's solution.

        """
        self.pheromone[i] = (1 - self.rho) * self.pheromone[i] + self.rho * (
            self.q / fitness
        )

    def generate_new_solution(self, i: int) -> np.ndarray:
        """Generate a new solution for the ant.

        Args:
            i (int): The index of the ant.

        Returns:
            np.ndarray: The new solution generated for the ant.

        """
        new_solution = self.ants[i] + self.pheromone[
            i
        ] ** self.alpha * np.random.default_rng(self.seed).uniform(-1, 1, self.dim)
        return np.clip(new_solution, self.lower_bound, self.upper_bound)

    def local_search(self, solution: np.ndarray) -> np.ndarray:
        """Perform a local search by adding a small perturbation to the solution.

        Args:
            solution (np.ndarray): The solution to perform local search on.

        Returns:
            np.ndarray: The new solution after local search.

        """
        new_solution = solution + np.random.default_rng(self.seed).uniform(
            -0.01, 0.01, self.dim
        )
        return np.clip(new_solution, self.lower_bound, self.upper_bound)


if __name__ == "__main__":
    optimizer = AntColony(
        func=shifted_ackley, lower_bound=-2.768, upper_bound=+2.768, dim=2
    )
    best_solution, best_fitness = optimizer.search()
    print(f"Best solution found: {best_solution}")
    print(f"Best fitness value: {best_fitness}")
