# generated by codegen_talib2.py
import talib as _ta
from polars import Expr, map_batches

from polars_ta.utils.numba_ import batches_i1_o1, batches_i1_o2, batches_i2_o1, batches_i2_o2


def HT_DCPERIOD(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.HT_DCPERIOD))


def HT_DCPHASE(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.HT_DCPHASE))


def HT_PHASOR(close: Expr, ret_idx: int = 1) -> Expr:  # ['inphase', 'quadrature']
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.HT_PHASOR, ret_idx=ret_idx))


def HT_SINE(close: Expr, ret_idx: int = 1) -> Expr:  # ['sine', 'leadsine']
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.HT_SINE, ret_idx=ret_idx))


def HT_TRENDMODE(close: Expr) -> Expr:  # ['integer']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.HT_TRENDMODE))


def ADD(high: Expr, low: Expr) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.ADD))


def DIV(high: Expr, low: Expr) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.DIV))


def MAX(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MAX, timeperiod))


def MAXINDEX(close: Expr, timeperiod: int = 30) -> Expr:  # ['integer']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MAXINDEX, timeperiod))


def MIN(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MIN, timeperiod))


def MININDEX(close: Expr, timeperiod: int = 30) -> Expr:  # ['integer']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MININDEX, timeperiod))


def MINMAX(close: Expr, timeperiod: int = 30, ret_idx: int = 1) -> Expr:  # ['min', 'max']
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MINMAX, timeperiod, ret_idx=ret_idx))


def MINMAXINDEX(close: Expr, timeperiod: int = 30, ret_idx: int = 1) -> Expr:  # ['minidx', 'maxidx']
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MINMAXINDEX, timeperiod, ret_idx=ret_idx))


def MULT(high: Expr, low: Expr) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.MULT))


def SUB(high: Expr, low: Expr) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.SUB))


def SUM(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.SUM, timeperiod))


def ACOS(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ACOS))


def ASIN(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ASIN))


def ATAN(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ATAN))


def CEIL(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.CEIL))


def COS(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.COS))


def COSH(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.COSH))


def EXP(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.EXP))


def FLOOR(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.FLOOR))


def LN(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LN))


def LOG10(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LOG10))


def SIN(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.SIN))


def SINH(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.SINH))


def SQRT(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.SQRT))


def TAN(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TAN))


def TANH(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TANH))


def ADX(high: Expr, low: Expr, close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.ADX, timeperiod))


def ADXR(high: Expr, low: Expr, close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.ADXR, timeperiod))


def APO(close: Expr, fastperiod: int = 12, slowperiod: int = 26, matype: int = 0) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.APO, fastperiod, slowperiod, matype))


def AROON(high: Expr, low: Expr, timeperiod: int = 14, ret_idx: int = 1) -> Expr:  # ['aroondown', 'aroonup']
    return map_batches([high, low], lambda xx: batches_i2_o2([x1.to_numpy().astype(float) for x1 in xx], _ta.AROON, timeperiod, ret_idx=ret_idx))


def AROONOSC(high: Expr, low: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.AROONOSC, timeperiod))


def BOP(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['real']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.BOP))


def CCI(high: Expr, low: Expr, close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CCI, timeperiod))


def CMO(close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.CMO, timeperiod))


def DX(high: Expr, low: Expr, close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.DX, timeperiod))


def MACD(close: Expr, fastperiod: int = 12, slowperiod: int = 26, signalperiod: int = 9, ret_idx: int = 2) -> Expr:  # ['macd', 'macdsignal', 'macdhist']
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MACD, fastperiod, slowperiod, signalperiod, ret_idx=ret_idx))


def MACDEXT(close: Expr, fastperiod: int = 12, fastmatype: int = 0, slowperiod: int = 26, slowmatype: int = 0, signalperiod: int = 9, signalmatype: int = 0, ret_idx: int = 2) -> Expr:  # ['macd', 'macdsignal', 'macdhist']
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MACDEXT, fastperiod, fastmatype, slowperiod, slowmatype, signalperiod, signalmatype, ret_idx=ret_idx))


def MACDFIX(close: Expr, signalperiod: int = 9, ret_idx: int = 2) -> Expr:  # ['macd', 'macdsignal', 'macdhist']
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MACDFIX, signalperiod, ret_idx=ret_idx))


def MFI(high: Expr, low: Expr, close: Expr, volume: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low, close, volume], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.MFI, timeperiod))


def MINUS_DI(high: Expr, low: Expr, close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.MINUS_DI, timeperiod))


def MINUS_DM(high: Expr, low: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.MINUS_DM, timeperiod))


def MOM(close: Expr, timeperiod: int = 10) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MOM, timeperiod))


def PLUS_DI(high: Expr, low: Expr, close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.PLUS_DI, timeperiod))


def PLUS_DM(high: Expr, low: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.PLUS_DM, timeperiod))


def PPO(close: Expr, fastperiod: int = 12, slowperiod: int = 26, matype: int = 0) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.PPO, fastperiod, slowperiod, matype))


def ROC(close: Expr, timeperiod: int = 10) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ROC, timeperiod))


def ROCP(close: Expr, timeperiod: int = 10) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ROCP, timeperiod))


def ROCR(close: Expr, timeperiod: int = 10) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ROCR, timeperiod))


def ROCR100(close: Expr, timeperiod: int = 10) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.ROCR100, timeperiod))


def RSI(close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.RSI, timeperiod))


def STOCH(high: Expr, low: Expr, close: Expr, fastk_period: int = 5, slowk_period: int = 3, slowk_matype: int = 0, slowd_period: int = 3, slowd_matype: int = 0, ret_idx: int = 1) -> Expr:  # ['slowk', 'slowd']
    return map_batches([high, low, close], lambda xx: batches_i2_o2([x1.to_numpy().astype(float) for x1 in xx], _ta.STOCH, fastk_period, slowk_period, slowk_matype, slowd_period, slowd_matype, ret_idx=ret_idx))


def STOCHF(high: Expr, low: Expr, close: Expr, fastk_period: int = 5, fastd_period: int = 3, fastd_matype: int = 0, ret_idx: int = 1) -> Expr:  # ['fastk', 'fastd']
    return map_batches([high, low, close], lambda xx: batches_i2_o2([x1.to_numpy().astype(float) for x1 in xx], _ta.STOCHF, fastk_period, fastd_period, fastd_matype, ret_idx=ret_idx))


def STOCHRSI(close: Expr, timeperiod: int = 14, fastk_period: int = 5, fastd_period: int = 3, fastd_matype: int = 0, ret_idx: int = 1) -> Expr:  # ['fastk', 'fastd']
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.STOCHRSI, timeperiod, fastk_period, fastd_period, fastd_matype, ret_idx=ret_idx))


def TRIX(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TRIX, timeperiod))


def ULTOSC(high: Expr, low: Expr, close: Expr, timeperiod1: int = 7, timeperiod2: int = 14, timeperiod3: int = 28) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.ULTOSC, timeperiod1, timeperiod2, timeperiod3))


def WILLR(high: Expr, low: Expr, close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.WILLR, timeperiod))


def BBANDS(close: Expr, timeperiod: int = 5, nbdevup: float = 2.0, nbdevdn: float = 2.0, matype: int = 0, ret_idx: int = 2) -> Expr:  # ['upperband', 'middleband', 'lowerband']
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.BBANDS, timeperiod, nbdevup, nbdevdn, matype, ret_idx=ret_idx))


def DEMA(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.DEMA, timeperiod))


def EMA(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.EMA, timeperiod))


def HT_TRENDLINE(close: Expr) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.HT_TRENDLINE))


def KAMA(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.KAMA, timeperiod))


def MA(close: Expr, timeperiod: int = 30, matype: int = 0) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MA, timeperiod, matype))


def MAMA(close: Expr, fastlimit: float = 0.5, slowlimit: float = 0.05, ret_idx: int = 1) -> Expr:  # ['mama', 'fama']
    return close.map_batches(lambda x1: batches_i1_o2(x1.to_numpy().astype(float), _ta.MAMA, fastlimit, slowlimit, ret_idx=ret_idx))


def MAVP(close: Expr, periods: Expr, minperiod: int = 2, maxperiod: int = 30, matype: int = 0) -> Expr:  # ['real']
    return map_batches([close, periods], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.MAVP, minperiod, maxperiod, matype))


def MIDPOINT(close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.MIDPOINT, timeperiod))


def MIDPRICE(high: Expr, low: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.MIDPRICE, timeperiod))


def SAR(high: Expr, low: Expr, acceleration: float = 0.02, maximum: float = 0.2) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.SAR, acceleration, maximum))


def SAREXT(high: Expr, low: Expr, startvalue: float = 0.0, offsetonreverse: float = 0.0, accelerationinitlong: float = 0.02, accelerationlong: float = 0.02, accelerationmaxlong: float = 0.2, accelerationinitshort: float = 0.02, accelerationshort: float = 0.02, accelerationmaxshort: float = 0.2) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.SAREXT, startvalue, offsetonreverse, accelerationinitlong, accelerationlong, accelerationmaxlong, accelerationinitshort, accelerationshort, accelerationmaxshort))


def SMA(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.SMA, timeperiod))


def T3(close: Expr, timeperiod: int = 5, vfactor: float = 0.7) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.T3, timeperiod, vfactor))


def TEMA(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TEMA, timeperiod))


def TRIMA(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TRIMA, timeperiod))


def WMA(close: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.WMA, timeperiod))


def CDL2CROWS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDL2CROWS))


def CDL3BLACKCROWS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDL3BLACKCROWS))


def CDL3INSIDE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDL3INSIDE))


def CDL3LINESTRIKE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDL3LINESTRIKE))


def CDL3OUTSIDE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDL3OUTSIDE))


def CDL3STARSINSOUTH(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDL3STARSINSOUTH))


def CDL3WHITESOLDIERS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDL3WHITESOLDIERS))


def CDLABANDONEDBABY(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.3) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLABANDONEDBABY, penetration))


def CDLADVANCEBLOCK(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLADVANCEBLOCK))


def CDLBELTHOLD(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLBELTHOLD))


def CDLBREAKAWAY(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLBREAKAWAY))


def CDLCLOSINGMARUBOZU(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLCLOSINGMARUBOZU))


def CDLCONCEALBABYSWALL(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLCONCEALBABYSWALL))


def CDLCOUNTERATTACK(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLCOUNTERATTACK))


def CDLDARKCLOUDCOVER(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.5) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLDARKCLOUDCOVER, penetration))


def CDLDOJI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLDOJI))


def CDLDOJISTAR(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLDOJISTAR))


def CDLDRAGONFLYDOJI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLDRAGONFLYDOJI))


def CDLENGULFING(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLENGULFING))


def CDLEVENINGDOJISTAR(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.3) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLEVENINGDOJISTAR, penetration))


def CDLEVENINGSTAR(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.3) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLEVENINGSTAR, penetration))


def CDLGAPSIDESIDEWHITE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLGAPSIDESIDEWHITE))


def CDLGRAVESTONEDOJI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLGRAVESTONEDOJI))


def CDLHAMMER(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLHAMMER))


def CDLHANGINGMAN(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLHANGINGMAN))


def CDLHARAMI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLHARAMI))


def CDLHARAMICROSS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLHARAMICROSS))


def CDLHIGHWAVE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLHIGHWAVE))


def CDLHIKKAKE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLHIKKAKE))


def CDLHIKKAKEMOD(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLHIKKAKEMOD))


def CDLHOMINGPIGEON(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLHOMINGPIGEON))


def CDLIDENTICAL3CROWS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLIDENTICAL3CROWS))


def CDLINNECK(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLINNECK))


def CDLINVERTEDHAMMER(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLINVERTEDHAMMER))


def CDLKICKING(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLKICKING))


def CDLKICKINGBYLENGTH(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLKICKINGBYLENGTH))


def CDLLADDERBOTTOM(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLLADDERBOTTOM))


def CDLLONGLEGGEDDOJI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLLONGLEGGEDDOJI))


def CDLLONGLINE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLLONGLINE))


def CDLMARUBOZU(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLMARUBOZU))


def CDLMATCHINGLOW(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLMATCHINGLOW))


def CDLMATHOLD(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.5) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLMATHOLD, penetration))


def CDLMORNINGDOJISTAR(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.3) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLMORNINGDOJISTAR, penetration))


def CDLMORNINGSTAR(open: Expr, high: Expr, low: Expr, close: Expr, penetration: float = 0.3) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLMORNINGSTAR, penetration))


def CDLONNECK(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLONNECK))


def CDLPIERCING(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLPIERCING))


def CDLRICKSHAWMAN(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLRICKSHAWMAN))


def CDLRISEFALL3METHODS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLRISEFALL3METHODS))


def CDLSEPARATINGLINES(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLSEPARATINGLINES))


def CDLSHOOTINGSTAR(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLSHOOTINGSTAR))


def CDLSHORTLINE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLSHORTLINE))


def CDLSPINNINGTOP(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLSPINNINGTOP))


def CDLSTALLEDPATTERN(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLSTALLEDPATTERN))


def CDLSTICKSANDWICH(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLSTICKSANDWICH))


def CDLTAKURI(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLTAKURI))


def CDLTASUKIGAP(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLTASUKIGAP))


def CDLTHRUSTING(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLTHRUSTING))


def CDLTRISTAR(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLTRISTAR))


def CDLUNIQUE3RIVER(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLUNIQUE3RIVER))


def CDLUPSIDEGAP2CROWS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLUPSIDEGAP2CROWS))


def CDLXSIDEGAP3METHODS(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['integer']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CDLXSIDEGAP3METHODS))


def AVGPRICE(open: Expr, high: Expr, low: Expr, close: Expr) -> Expr:  # ['real']
    return map_batches([open, high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.AVGPRICE))


def MEDPRICE(high: Expr, low: Expr) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.MEDPRICE))


def TYPPRICE(high: Expr, low: Expr, close: Expr) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.TYPPRICE))


def WCLPRICE(high: Expr, low: Expr, close: Expr) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.WCLPRICE))


def BETA(high: Expr, low: Expr, timeperiod: int = 5) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.BETA, timeperiod))


def CORREL(high: Expr, low: Expr, timeperiod: int = 30) -> Expr:  # ['real']
    return map_batches([high, low], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.CORREL, timeperiod))


def LINEARREG(close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LINEARREG, timeperiod))


def LINEARREG_ANGLE(close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LINEARREG_ANGLE, timeperiod))


def LINEARREG_INTERCEPT(close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LINEARREG_INTERCEPT, timeperiod))


def LINEARREG_SLOPE(close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.LINEARREG_SLOPE, timeperiod))


def STDDEV(close: Expr, timeperiod: int = 5, nbdev: float = 1.0) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.STDDEV, timeperiod, nbdev))


def TSF(close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.TSF, timeperiod))


def VAR(close: Expr, timeperiod: int = 5, nbdev: float = 1.0) -> Expr:  # ['real']
    return close.map_batches(lambda x1: batches_i1_o1(x1.to_numpy().astype(float), _ta.VAR, timeperiod, nbdev))


def ATR(high: Expr, low: Expr, close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.ATR, timeperiod))


def NATR(high: Expr, low: Expr, close: Expr, timeperiod: int = 14) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.NATR, timeperiod))


def TRANGE(high: Expr, low: Expr, close: Expr) -> Expr:  # ['real']
    return map_batches([high, low, close], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.TRANGE))


def AD(high: Expr, low: Expr, close: Expr, volume: Expr) -> Expr:  # ['real']
    return map_batches([high, low, close, volume], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.AD))


def ADOSC(high: Expr, low: Expr, close: Expr, volume: Expr, fastperiod: int = 3, slowperiod: int = 10) -> Expr:  # ['real']
    return map_batches([high, low, close, volume], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.ADOSC, fastperiod, slowperiod))


def OBV(close: Expr, volume: Expr) -> Expr:  # ['real']
    return map_batches([close, volume], lambda xx: batches_i2_o1([x1.to_numpy().astype(float) for x1 in xx], _ta.OBV))
