{"guide": {"name": "backend", "category": "custom-components", "pretty_category": "Custom Components", "guide_index": 4, "absolute_index": 35, "pretty_name": "Backend", "content": "# The Backend \ud83d\udc0d\n\nThis guide will cover everything you need to know to implement your custom component's backend processing.\n\n## Which Class to Inherit From\n\nAll components inherit from one of three classes `Component`, `FormComponent`, or `BlockContext`.\nYou need to inherit from one so that your component behaves like all other gradio components.\nWhen you start from a template with `gradio cc create --template`, you don't need to worry about which one to choose since the template uses the correct one. \nFor completeness, and in the event that you need to make your own component from scratch, we explain what each class is for.\n\n* `FormComponent`: Use this when you want your component to be grouped together in the same `Form` layout with other `FormComponents`. The `Slider`, `Textbox`, and `Number` components are all `FormComponents`.\n* `BlockContext`: Use this when you want to place other components \"inside\" your component. This enabled `with MyComponent() as component:` syntax.\n* `Component`: Use this for all other cases.<p class='tip'><strong>\u270d\ufe0f Tip:</strong> If your component supports streaming output, inherit from the `StreamingOutput` class.</p><p class='tip'><strong>\u270d\ufe0f Tip:</strong> If you inherit from `BlockContext`, you also need to set the metaclass to be `ComponentMeta`. See example below.</p>\n\n```python\nfrom gradio.blocks import BlockContext\nfrom gradio.component_meta import ComponentMeta\n\n\n\n\n@document()\nclass Row(BlockContext, metaclass=ComponentMeta):\n    pass\n```\n\n## The methods you need to implement\n\nWhen you inherit from any of these classes, the following methods must be implemented.\nOtherwise the Python interpreter will raise an error when you instantiate your component!\n\n### `preprocess` and `postprocess`\n\nExplained in the [Key Concepts](./key-component-concepts#the-value-and-how-it-is-preprocessed-postprocessed) guide. \nThey handle the conversion from the data sent by the frontend to the format expected by the python function.\n\n```python\n    def preprocess(self, x: Any) -> Any:\n        \"\"\"\n        Convert from the web-friendly (typically JSON) value in the frontend to the format expected by the python function.\n        \"\"\"\n        return x\n\n    def postprocess(self, y):\n        \"\"\"\n        Convert from the data returned by the python function to the web-friendly (typically JSON) value expected by the frontend.\n        \"\"\"\n        return y\n```\n\n### `process_example`\n\nTakes in the original Python value and returns the modified value that should be displayed in the examples preview in the app. \nIf not provided, the `.postprocess()` method is used instead. Let's look at the following example from the `SimpleDropdown` component.\n\n```python\ndef process_example(self, input_data):\n    return next((c[0] for c in self.choices if c[1] == input_data), None)\n```\n\nSince `self.choices` is a list of tuples corresponding to (`display_name`, `value`), this converts the value that a user provides to the display value (or if the value is not present in `self.choices`, it is converted to `None`).\n\n\n### `api_info`\n\nA JSON-schema representation of the value that the `preprocess` expects. \nThis powers api usage via the gradio clients. \nYou do **not** need to implement this yourself if you components specifies a `data_model`. \nThe `data_model` in the following section.\n\n```python\ndef api_info(self) -> dict[str, list[str]]:\n    \"\"\"\n    A JSON-schema representation of the value that the `preprocess` expects and the `postprocess` returns.\n    \"\"\"\n    pass\n```\n\n### `example_payload`\n\nAn example payload for your component, e.g. something that can be passed into the `.preprocess()` method\nof your component. The example input is displayed in the `View API` page of a Gradio app that uses your custom component. \nMust be JSON-serializable. If your component expects a file, it is best to use a publicly accessible URL.\n\n```python\ndef example_payload(self) -> Any:\n    \"\"\"\n    The example inputs for this component for API usage. Must be JSON-serializable.\n    \"\"\"\n    pass\n```\n\n### `example_value`\n\nAn example value for your component, e.g. something that can be passed into the `.postprocess()` method\nof your component. This is used as the example value in the default app that is created in custom component development.\n\n```python\ndef example_payload(self) -> Any:\n    \"\"\"\n    The example inputs for this component for API usage. Must be JSON-serializable.\n    \"\"\"\n    pass\n```\n\n### `flag`\n\nWrite the component's value to a format that can be stored in the `csv` or `json` file used for flagging.\nYou do **not** need to implement this yourself if you components specifies a `data_model`. \nThe `data_model` in the following section.\n\n```python\ndef flag(self, x: Any | GradioDataModel, flag_dir: str | Path = \"\") -> str:\n    pass\n```\n\n### `read_from_flag`\nConvert from the format stored in the `csv` or `json` file used for flagging to the component's python `value`.\nYou do **not** need to implement this yourself if you components specifies a `data_model`. \nThe `data_model` in the following section.\n\n```python\ndef read_from_flag(\n    self,\n    x: Any,\n) -> GradioDataModel | Any:\n    \"\"\"\n    Convert the data from the csv or jsonl file into the component state.\n    \"\"\"\n    return x\n```\n\n## The `data_model`\n\nThe `data_model` is how you define the expected data format your component's value will be stored in the frontend.\nIt specifies the data format your `preprocess` method expects and the format the `postprocess` method returns.\nIt is not necessary to define a `data_model` for your component but it greatly simplifies the process of creating a custom component.\nIf you define a custom component you only need to implement four methods - `preprocess`, `postprocess`, `example_payload`, and `example_value`!\n\nYou define a `data_model` by defining a [pydantic model](https://docs.pydantic.dev/latest/concepts/models/#basic-model-usage) that inherits from either `GradioModel` or `GradioRootModel`.\n\nThis is best explained with an example. Let's look at the core `Video` component, which stores the video data as a JSON object with two keys `video` and `subtitles` which point to separate files.\n\n```python\nfrom gradio.data_classes import FileData, GradioModel\n\nclass VideoData(GradioModel):\n    video: FileData\n    subtitles: Optional[FileData] = None\n\nclass Video(Component):\n    data_model = VideoData\n```\n\nBy adding these four lines of code, your component automatically implements the methods needed for API usage, the flagging methods, and example caching methods!\nIt also has the added benefit of self-documenting your code.\nAnyone who reads your component code will know exactly the data it expects.<p class='tip'><strong>\u270d\ufe0f Tip:</strong> If your component expects files to be uploaded from the frontend, your must use the `FileData` model! It will be explained in the following section. </p><p class='tip'><strong>\u270d\ufe0f Tip:</strong> Read the pydantic docs [here](https://docs.pydantic.dev/latest/concepts/models/#basic-model-usage).</p>\n\nThe difference between a `GradioModel` and a `GradioRootModel` is that the `RootModel` will not serialize the data to a dictionary.\nFor example, the `Names` model will serialize the data to `{'names': ['freddy', 'pete']}` whereas the `NamesRoot` model will serialize it to `['freddy', 'pete']`.\n\n```python\nfrom typing import List\n\nclass Names(GradioModel):\n    names: List[str]\n\nclass NamesRoot(GradioRootModel):\n    root: List[str]\n```\n\nEven if your component does not expect a \"complex\" JSON data structure it can be beneficial to define a `GradioRootModel` so that you don't have to worry about implementing the API and flagging methods.<p class='tip'><strong>\u270d\ufe0f Tip:</strong> Use classes from the Python typing library to type your models. e.g. `List` instead of `list`.</p>\n\n## Handling Files\n\nIf your component expects uploaded files as input, or returns saved files to the frontend, you **MUST** use the `FileData` to type the files in your `data_model`.\n\nWhen you use the `FileData`:\n\n* Gradio knows that it should allow serving this file to the frontend. Gradio automatically blocks requests to serve arbitrary files in the computer running the server.\n\n* Gradio will automatically place the file in a cache so that duplicate copies of the file don't get saved.\n\n* The client libraries will automatically know that they should upload input files prior to sending the request. They will also automatically download files.\n\nIf you do not use the `FileData`, your component will not work as expected!\n\n\n## Adding Event Triggers To Your Component\n\nThe events triggers for your component are defined in the `EVENTS` class attribute.\nThis is a list that contains the string names of the events.\nAdding an event to this list will automatically add a method with that same name to your component!\n\nYou can import the `Events` enum from `gradio.events` to access commonly used events in the core gradio components.\n\nFor example, the following code will define `text_submit`, `file_upload` and `change` methods in the `MyComponent` class.\n\n```python\nfrom gradio.events import Events\nfrom gradio.components import FormComponent\n\nclass MyComponent(FormComponent):\n\n    EVENTS = [\n        \"text_submit\",\n        \"file_upload\",\n        Events.change\n    ]\n```\n<p class='tip'><strong>\u270d\ufe0f Tip:</strong> Don't forget to also handle these events in the JavaScript code!</p>\n\n## Conclusion\n\n", "tags": [], "spaces": [], "url": "/guides/backend/", "contributor": null}}