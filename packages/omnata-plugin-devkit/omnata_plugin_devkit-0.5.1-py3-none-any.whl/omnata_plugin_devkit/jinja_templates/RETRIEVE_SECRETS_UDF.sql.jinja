create or replace function PLUGIN.RETRIEVE_SECRETS_UDF(OAUTH_SECRET_NAME VARCHAR,OTHER_SECRETS_NAME VARCHAR)
returns object
language python
RUNTIME_VERSION = '3.10'
HANDLER = 'run'
as
$$
import _snowflake # pylint: disable=import-error, import-outside-toplevel # type: ignore
from logging import getLogger
import json
logger = getLogger(__name__)
def run(oauth_secret_name,other_secrets_name):
   connection_secrets = {}
   if oauth_secret_name is not None:
      connection_secrets["access_token"] = {
            "value" :_snowflake.get_oauth_access_token(oauth_secret_name)
      }

   if other_secrets_name is not None:
      try:
            secret_string_content = _snowflake.get_generic_secret_string(
               other_secrets_name
            )
            if len(secret_string_content) > 2:
               other_secrets = json.loads(secret_string_content)
               connection_secrets = {
                  **connection_secrets,
                  **other_secrets,
               }
      except Exception as exception:
            logger.error(f"Error parsing secrets content for secret {other_secrets_name}: {str(exception)}")
            raise ValueError(f"Error parsing secrets content: {str(exception)}") from exception
   return connection_secrets
$$
;
   
-- we don't grant this to OMNATA_MANAGEMENT because we'd rather the sync engine couldn't read secrets back once created

-- we didn't end up doing this because developers should generally be running in debug mode anyway
--grant usage on procedure PLUGIN.RETRIEVE_SECRETS_UDF(VARCHAR,VARCHAR)
--to application role PLUGIN_DEVELOPER;
