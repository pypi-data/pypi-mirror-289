- name: get master architecture
  set_fact:
    master_arch: "{{ hostvars[groups['master'][0]].ansible_architecture }}"

- name: unarchive master architecture k8s base images on localhost
  ansible.builtin.unarchive:
    src: "{{ k8s_image_dir }}/{{ master_arch }}.tar.gz"
    dest: "{{ k8s_image_dir }}"
    remote_src: yes
  when:
     - use_old_k8s_version

- name: unarchive master architecture k8s base images on localhost
  ansible.builtin.unarchive:
    src: "{{ k8s_image_dir }}/{{ master_arch }}_125.tar.gz"
    dest: "{{ k8s_image_dir }}"
    remote_src: yes
  when:
     - not use_old_k8s_version

# 查看master节点架构下的k8s镜像
- name: list k8s component dir
  command: "ls {{k8s_image_dir}}/{{ master_arch }}"
  register: master_arch_image


# 镜像名保存格式：xxxx_架构:tag，带"架构"方便后续处理
- name: load master node arch offline k8s image
  shell:
    cmd:
      image="$(cd {{k8s_image_dir}}/{{ master_arch }} && docker load -i {{ item }} | grep "Loaded image" | awk '{print $3}')";
      imageName="$(echo ${image} | awk -F ":" '{print $1}')";
      imageNameShort="$(echo $imageName | cut -d'/' -f1,3)";
      imageName="$( [[ $imageNameShort == *"/"* ]] && echo $imageNameShort || echo $imageName)";
      imageTag="$(echo ${image} | awk -F ":" '{print $2}')";
      docker tag "${image}" "{{ HARBOR_SERVER }}/${imageName}_{{ master_arch }}:${imageTag}";
      echo "${imageName}_{{ master_arch }}:${imageTag}";
  args:
    executable: /bin/bash
  loop: "{{ master_arch_image.stdout_lines }}"
  register: k8s_base_images

# 根据导入的k8s镜像，创建对应的project
- name: create harbor project
  uri:
    url: "{{'http://' if HARBOR_HTTP else 'https://'}}{{ HARBOR_SERVER }}/api/v2.0/projects"
    method: POST
    validate_certs: false
    return_content: yes
    user: "{{ HARBOR_ADMIN_USER }}"
    password: "{{ HARBOR_ADMIN_PASSWORD }}"
    force_basic_auth: yes
    status_code: [200, 201, 409]
    body: '{"project_name": "{{ item.stdout.split("/")[0] }}", "metadata": {"public": "true"}, "storage_limit": -1}'
    body_format: json
  loop: "{{ k8s_base_images['results'] }}"
  environment:
    http_proxy: ""
    https_proxy: ""
    HTTP_PROXY: ""
    HTTPS_PROXY: ""
  no_log: true
  ignore_errors: true
  when:
    - "'/' in item.stdout "

- name: clean old manifest
  shell:
    cmd:
      manifest_name="{{ HARBOR_SERVER }}/{{ item.stdout.replace('_'+master_arch+':', ':') }}";
      chmod 755 "{{ docker_20_bin_dir }}/docker-{{ ansible_architecture }}";
      "{{ docker_20_bin_dir }}/docker-{{ ansible_architecture }}" manifest rm "${manifest_name}" > /dev/null 2>&1 || true
  loop: "{{ k8s_base_images['results'] }}"
  environment:
    DOCKER_CLI_EXPERIMENTAL: enabled
    http_proxy: ""
    https_proxy: ""
    HTTP_PROXY: ""
    HTTPS_PROXY: ""
  ignore_errors: true
  when:
    - k8s_base_images is defined and 'results' in k8s_base_images and k8s_base_images['results'] | length > 0

# 开启实验特性再使用manifest
# 先将原始镜像推送到harbor，再创建manifest
# item.stdout格式 xxxxx_架构:tag
# 一定要用annotate，不然推送导入的arm镜像在x86服务器上会被标记为x86架构
- name: create manifest master node arch
  shell:
    cmd:
      manifest_name={{ HARBOR_SERVER }}/{{ item.stdout.replace('_'+master_arch+':', ':') }};
      master_image={{ HARBOR_SERVER }}/{{ item.stdout }};
      docker push "${master_image}";
      docker manifest create --insecure "${manifest_name}"  --amend "${master_image}";
      docker manifest annotate --arch "{{ 'arm64' if master_arch == 'aarch64' else 'amd64' }}" "${manifest_name}" "${master_image}";
  loop: "{{ k8s_base_images['results'] }}"
  environment:
    DOCKER_CLI_EXPERIMENTAL: enabled
    http_proxy: ""
    https_proxy: ""
    HTTP_PROXY: ""
    HTTPS_PROXY: ""

- name: push manifest
  shell:
    cmd:
      manifest_name="{{ HARBOR_SERVER }}/{{ item.stdout.replace('_'+master_arch+':', ':') }}";
      chmod 755 {{ docker_20_bin_dir }}/docker-{{ ansible_architecture }};
      {{ docker_20_bin_dir }}/docker-{{ ansible_architecture }} manifest push -p --insecure "${manifest_name}";
  loop: "{{ k8s_base_images['results'] }}"
  environment:
    DOCKER_CLI_EXPERIMENTAL: enabled
    http_proxy: ""
    https_proxy: ""
    HTTP_PROXY: ""
    HTTPS_PROXY: ""